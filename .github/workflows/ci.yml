name: SQL CI

on:
  push:
    branches: [ main ]
  pull_request:

jobs:
  test:
    runs-on: ubuntu-latest
    env:
      COMPOSE_PROJECT_NAME: sql_project  # фиксируем имя compose-проекта

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Compose up (build image with pgTAP)
        run: docker compose up -d --build

      - name: Wait for Postgres socket (pg_isready)
        run: |
          for i in {1..300}; do
            if docker compose exec -T db pg_isready -U app -d appdb; then
              echo "Postgres socket is up"; exit 0
            fi
            echo "Waiting for Postgres socket... ($i/300)"
            sleep 2
          done
          echo "Postgres did not become ready (socket)" && exit 1

      - name: Wait for schema, data and matview (robust retries)
        shell: bash
        run: |
          set -u

          run_sql() {
            # Выполняем psql, на любые ошибки/рестарты возвращаем специальный маркер
            docker compose exec -T db bash -lc "psql -U app -d appdb -tAc \"$1\"" 2>/dev/null || echo "__ERR__"
          }

          wait_bool() {
            local sql="$1"; local what="$2"; local tries="$3"
            for ((i=1;i<=tries;i++)); do
              out=$(run_sql "$sql")
              if [[ "$out" == "t" ]]; then
                echo "$what: OK"; return 0
              fi
              echo "Waiting for $what... ($i/$tries) out='$out'"
              sleep 2
            done
            echo "Timeout while waiting for $what"; return 1
          }

          wait_count_ge() {
            local sql="$1"; local what="$2"; local ge="$3"; local tries="$4"
            for ((i=1;i<=tries;i++)); do
              out=$(run_sql "$sql")
              # если ошибка подключения — продолжаем ждать
              if [[ "$out" == "__ERR__" || -z "$out" ]]; then
                echo "Waiting for $what (db not ready)... ($i/$tries)"
                sleep 2
                continue
              fi
              # чистим пробелы и перевод строки
              out=$(echo "$out" | tr -d '[:space:]')
              if [[ "$out" =~ ^[0-9]+$ && "$out" -ge "$ge" ]]; then
                echo "$what: $out (>= $ge) — OK"; return 0
              fi
              echo "Waiting for $what... now=$out need>=$ge ($i/$tries)"
              sleep 2
            done
            echo "Timeout while waiting for $what"; return 1
          }

          # 1) есть ли схема/таблица
          wait_bool "SELECT to_regclass('dw.dim_books') IS NOT NULL" "dw.dim_books exists" 600

          # 2) догрузились ли книги (ожидаем 10k)
          wait_count_ge "SELECT COALESCE((SELECT COUNT(*) FROM dw.dim_books),0)" "dw.dim_books count" 10000 600

          # 3) появилась ли матвью
          wait_bool "SELECT to_regclass('dw.mv_top_books_quality') IS NOT NULL" "dw.mv_top_books_quality exists" 600

          # 4) загрузился ли bridge (ориентир ~1e6)
          wait_count_ge "SELECT COALESCE((SELECT COUNT(*) FROM dw.bridge_book_tags),0)" "dw.bridge_book_tags count" 900000 600

          # перестрахуемся: рефреш матвью (если уникальный индекс есть — concurrent)
          run_sql "REFRESH MATERIALIZED VIEW CONCURRENTLY dw.mv_top_books_quality" >/dev/null

      - name: Ensure pgTAP (idempotent)
        run: docker compose exec -T db psql -U app -d appdb -f /tests/pgtap_setup.sql

      - name: Run pgTAP tests
        run: |
          docker compose exec -T db psql -U app -d appdb -f /tests/test_basic.sql
          docker compose exec -T db psql -U app -d appdb -f /tests/test_queries.sql

      - name: Run showcase (absolute paths inside container)
        run: docker compose exec -T db bash -lc "psql -U app -d appdb -f /analytics/readme_index.sql > /analytics/run.log 2>&1"

      - name: Show /analytics/run.log (tail)
        if: always()
        run: |
          CID=$(docker compose ps -q db || true)
          if [ -n "$CID" ] && docker exec "$CID" test -f /analytics/run.log; then
            echo "----- tail /analytics/run.log -----"
            docker exec "$CID" tail -n 200 /analytics/run.log || true
          else
            echo "run.log not found in container"
          fi

      - name: Copy run.log out
        if: always()
        run: |
          CID=$(docker compose ps -q db || true)
          if [ -n "$CID" ]; then
            docker cp "$CID":/analytics/run.log ./analytics/run.log || true
          fi

      - name: Upload run.log
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: readme-runlog
          path: ./analytics/run.log
          if-no-files-found: warn

      - name: Dump DB logs on failure
        if: failure()
        run: docker compose logs --no-color --tail=300 db

      - name: Save DB logs as artifact
        if: always()
        run: docker compose logs --no-color db > db.logs.txt || true

      - name: Upload DB logs
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: db-logs
          path: db.logs.txt

      - name: Compose down (cleanup)
        if: always()
        run: docker compose down -v
