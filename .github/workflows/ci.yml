name: SQL CI

on:
  push:
    branches: [ main ]
  pull_request:

jobs:
  test:
    runs-on: ubuntu-latest

    # фиксируем имя compose-проекта — стабильные имена контейнеров
    env:
      COMPOSE_PROJECT_NAME: sql_project

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Compose up (build image with pgTAP)
        run: docker compose up -d --build

      - name: Wait for Postgres socket (pg_isready)
        run: |
          for i in {1..300}; do
            if docker compose exec -T db pg_isready -U app -d appdb; then
              echo "Postgres socket is up"
              exit 0
            fi
            echo "Waiting for Postgres socket... ($i/300)"
            sleep 2
          done
          echo "Postgres did not become ready (socket)" && exit 1

      - name: Wait for DB init to finish (schema + data + matview)
        run: |
          set -e

          # Ждём появления схемы/таблиц
          for i in {1..600}; do
            has_books=$(docker compose exec -T db psql -U app -d appdb -tAc "SELECT to_regclass('dw.dim_books') IS NOT NULL")
            if [ "$has_books" = "t" ]; then
              echo "dw.dim_books exists"
              break
            fi
            echo "Waiting for dw.dim_books to appear... ($i/600)"
            sleep 2
          done

          # Ждём пока загрузятся книги (ориентир: 10k)
          for i in {1..600}; do
            cnt=$(docker compose exec -T db psql -U app -d appdb -tAc "SELECT COALESCE((SELECT COUNT(*) FROM dw.dim_books),0)")
            echo "dw.dim_books count: $cnt"
            if [ "$cnt" -ge 10000 ]; then
              break
            fi
            sleep 2
          done

          # Ждём матвью
          for i in {1..600}; do
            has_mv=$(docker compose exec -T db psql -U app -d appdb -tAc "SELECT to_regclass('dw.mv_top_books_quality') IS NOT NULL")
            if [ "$has_mv" = "t" ]; then
              echo "dw.mv_top_books_quality exists"
              break
            fi
            echo "Waiting for dw.mv_top_books_quality... ($i/600)"
            sleep 2
          done

          # Бридж тегов (ориентир: ~1e6)
          for i in {1..600}; do
            bt=$(docker compose exec -T db psql -U app -d appdb -tAc "SELECT COALESCE((SELECT COUNT(*) FROM dw.bridge_book_tags),0)")
            echo "dw.bridge_book_tags count: $bt"
            if [ "$bt" -ge 900000 ]; then
              break
            fi
            sleep 2
          done

      - name: Ensure pgTAP (idempotent)
        run: docker compose exec -T db psql -U app -d appdb -f /tests/pgtap_setup.sql

      - name: Run pgTAP tests
        run: |
          docker compose exec -T db psql -U app -d appdb -f /tests/test_basic.sql
          docker compose exec -T db psql -U app -d appdb -f /tests/test_queries.sql

      - name: Run showcase (absolute paths inside container)
        run: docker compose exec -T db bash -lc "psql -U app -d appdb -f /analytics/readme_index.sql > /analytics/run.log 2>&1"

      - name: Show /analytics/run.log (tail)
        if: always()
        run: |
          CID=$(docker compose ps -q db || true)
          if [ -n "$CID" ] && docker exec "$CID" test -f /analytics/run.log; then
            echo "----- tail /analytics/run.log -----"
            docker exec "$CID" tail -n 200 /analytics/run.log || true
          else
            echo "run.log not found in container"
          fi

      - name: Copy run.log out
        if: always()
        run: |
          CID=$(docker compose ps -q db || true)
          if [ -n "$CID" ]; then
            docker cp "$CID":/analytics/run.log ./analytics/run.log || true
          fi

      - name: Upload run.log
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: readme-runlog
          path: ./analytics/run.log
          if-no-files-found: warn

      - name: Dump DB logs on failure
        if: failure()
        run: docker compose logs --no-color --tail=300 db

      - name: Save DB logs as artifact
        if: always()
        run: docker compose logs --no-color db > db.logs.txt || true

      - name: Upload DB logs
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: db-logs
          path: db.logs.txt

      - name: Compose down (cleanup)
        if: always()
        run: docker compose down -v
